const mongoose = require('mongoose');

// Counter for automatic invoice numbering
const invoiceCounterSchema = new mongoose.Schema({
  year: { type: Number, required: true, unique: true },
  count: { type: Number, default: 0 }
});

const InvoiceCounter = mongoose.model('InvoiceCounter', invoiceCounterSchema);

const invoiceSchema = new mongoose.Schema({
    invoiceNumber: {
        type: String,
        required: false, // Generated by pre-save hook
        trim: true,
        uppercase: true,
    },
    building: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Building',
        required: true
    },
    workOrders: [{
        workOrder: { type: mongoose.Schema.Types.ObjectId, ref: 'WorkOrder' },
        description: String,
        quantity: Number,
        unitPrice: Number,
        totalPrice: Number
    }],
    lineItems: [{
        description: String,
        quantity: Number,
        unitPrice: Number,
        totalPrice: Number
    }],
    subtotal: { type: Number, required: true, default: 0 },
    tax: { type: Number, default: 0 },
    total: { type: Number, required: true, default: 0 },
    status: {
        type: String,
        enum: ['draft', 'open', 'sent', 'paid', 'overdue', 'cancelled'],
        default: 'open'
    },
    invoiceDate: { type: Date, default: Date.now },
    dueDate: Date,
    paidDate: Date,
    notes: String,
    
    // Audit Trail Fields
    createdBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    },
    updatedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    },

    // Soft Delete Fields
    deleted: {
        type: Boolean,
        default: false,
        select: false // Exclude from results by default
    },
    deletedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        select: false
    },
    deletedAt: {
        type: Date,
        select: false
    },

    statusHistory: [{
        status: String,
        timestamp: { type: Date, default: Date.now },
        notes: String
    }]
}, {
    timestamps: true // Adds createdAt and updatedAt automatically
});

// Hook to exclude soft-deleted documents from all find queries
invoiceSchema.pre(/^find/, function(next) {
  this.where({ deleted: { $ne: true } });
  next();
});

// All other methods and hooks remain the same...

// Generate consecutive invoice number
invoiceSchema.pre('save', async function(next) {
    if (this.isNew && !this.invoiceNumber) {
        try {
            const currentYear = new Date().getFullYear();
            console.log('Generating invoice number for year:', currentYear);
            let counter = await InvoiceCounter.findOneAndUpdate(
                { year: currentYear },
                { $inc: { count: 1 } },
                { new: true, upsert: true }
            );
            console.log('Counter result:', counter);
            if (!counter || !counter.count) {
                throw new Error('Failed to generate counter');
            }
            this.invoiceNumber = `${currentYear}-${String(counter.count).padStart(4, '0')}`;
            console.log('Generated invoice number:', this.invoiceNumber);
        } catch (err) {
            console.error('Error generating invoice number:', err);
            // Fallback to timestamp-based number
            this.invoiceNumber = `INV-${Date.now()}`;
            console.log('Using fallback invoice number:', this.invoiceNumber);
        }
    }
    next();
});

// Pre-save hook to auto-mark invoices as overdue if past due date
invoiceSchema.pre('save', function(next) {
    try {
        // Initialize statusHistory if it doesn't exist
        if (!this.statusHistory) {
            this.statusHistory = [];
        }
        
        if (this.status !== 'paid' && this.status !== 'cancelled' && this.dueDate) {
            const now = new Date();
            const dueDate = new Date(this.dueDate);
            if (now > dueDate && this.status !== 'overdue') {
                this.status = 'overdue';
                this.statusHistory.push({
                    status: 'overdue',
                    timestamp: new Date(),
                    notes: 'Automatically marked as overdue - due date passed'
                });
            }
        }
        next();
    } catch (error) {
        console.error('Error in invoice pre-save hook:', error);
        next(error);
    }
});

// Post-find hook to recalculate totals when invoices are retrieved
invoiceSchema.post('find', function(docs) {
    if (!Array.isArray(docs)) return;
    docs.forEach(doc => {
        if (doc && typeof doc.calculateTotals === 'function') {
            doc.calculateTotals();
        }
    });
});

// Post-findOne hook to recalculate totals for single invoice retrieval
invoiceSchema.post('findOne', function(doc) {
    if (doc && typeof doc.calculateTotals === 'function') {
        doc.calculateTotals();
    }
});

// Method to calculate totals
invoiceSchema.methods.calculateTotals = function() {
    const items = (this.workOrders && this.workOrders.length > 0) ? this.workOrders : this.lineItems;
    this.subtotal = items.reduce((sum, item) => sum + (item.totalPrice || 0), 0);
    this.total = this.subtotal + (this.tax || 0);
};

const Invoice = mongoose.model('Invoice', invoiceSchema);

// Ensure invoiceNumber is unique only for non-deleted invoices.
// This migrates any existing global unique index on invoiceNumber to a
// partial unique index that ignores documents where deleted === true.
Invoice.init()
	.then(async () => {
		try {
			const indexes = await Invoice.collection.indexes();
			const invoiceNumberIndex = indexes.find(idx => idx.name === 'invoiceNumber_1');
			if (invoiceNumberIndex && !invoiceNumberIndex.partialFilterExpression) {
				console.log('Updating invoiceNumber_1 index to be partial unique on non-deleted invoices');
				await Invoice.collection.dropIndex('invoiceNumber_1');
				await Invoice.collection.createIndex(
					{ invoiceNumber: 1 },
					{ unique: true, partialFilterExpression: { deleted: { $ne: true } } }
				);
				console.log('invoiceNumber_1 index updated successfully');
			}
		} catch (err) {
			console.error('Error ensuring invoiceNumber index configuration:', err);
		}
	})
	.catch(err => {
		console.error('Error initializing Invoice model indexes:', err);
	});

module.exports = { Invoice, InvoiceCounter };
